#!/usr/bin/env bash
set -e

if [ "$#" -lt 2 ]; then
  echo "Usage: weave-view <view-name> <src-dir1> [src-dir2...] [--sys <sdk-dir1>...]"
  exit 1
fi

INPUT_NAME="$1"; shift
if [[ "$INPUT_NAME" == view-* ]]; then VIEW_NAME="$INPUT_NAME"; else VIEW_NAME="view-$INPUT_NAME"; fi

# Resolve Script Directory (to find siblings like weave-headers)
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

echo "ðŸ§µ Weaving virtual view: $VIEW_NAME"
mkdir -p "$VIEW_NAME/_sys"

JQ_ARGS=""; MODE=0
declare -a SRC_PATHS
ROOT_DIR="$(pwd)"

for arg in "$@"; do
  if [ "$arg" == "--sys" ]; then MODE=1; continue; fi
  if [[ "$arg" = /* ]]; then ABS="$arg"; else ABS="$ROOT_DIR/$arg"; fi
  
  if [ $MODE -eq 0 ]; then
    REL=$(dirname "$arg"); mkdir -p "$VIEW_NAME/$REL"
    ln -sf "$ABS" "$VIEW_NAME/$arg"
    SRC_PATHS+=("$ABS")
    if [ -z "$JQ_ARGS" ]; then JQ_ARGS=".file | startswith(\"$ABS\")";
    else JQ_ARGS="$JQ_ARGS or (.file | startswith(\"$ABS\"))"; fi
  else
    ln -sf "$ABS" "$VIEW_NAME/_sys/$(basename "$arg")"
  fi
done

# --- JSON Generation ---
echo "   [i] Searching for compilation databases..."
DB_LIST=$(mktemp)
if [ -f "compile_commands.json" ]; then echo "$ROOT_DIR/compile_commands.json" >> $DB_LIST; fi
for path in "${SRC_PATHS[@]}"; do
    find "$path" -maxdepth 3 -name "compile_commands.json" >> $DB_LIST 2>/dev/null || true
done

UNIQUE_DBS=$(cat $DB_LIST | sort | uniq)
TARGET_JSON="$VIEW_NAME/compile_commands.json"

if [ ! -z "$UNIQUE_DBS" ] && [ ! -z "$JQ_ARGS" ]; then
    if command -v jq &> /dev/null; then
        RAW_JSON=$(cat $UNIQUE_DBS | jq -s "add")
        SAMPLE_PATH=$(echo "$RAW_JSON" | jq -r '.[0].file // empty')
        
        # Rewrite Host Paths if needed
        if [ ! -z "$SAMPLE_PATH" ] && [[ "$SAMPLE_PATH" != "$ROOT_DIR"* ]]; then
            echo "   [!] Detected Path Mismatch (Host vs Container)"
            FIRST_SRC="${SRC_PATHS[0]}" 
            REL_PATH="${FIRST_SRC#$ROOT_DIR}"
            HOST_ROOT="${SAMPLE_PATH%$REL_PATH}"
            if [ ! -z "$HOST_ROOT" ] && [ "$HOST_ROOT" != "$SAMPLE_PATH" ]; then
                 RAW_JSON=$(echo "$RAW_JSON" | sed "s|$HOST_ROOT|$ROOT_DIR|g")
            fi
        fi

        echo "$RAW_JSON" | jq "[.[] | select($JQ_ARGS)]" > "$TARGET_JSON"
        COUNT=$(jq length "$TARGET_JSON")
        echo "   [âœ“] Master compile_commands.json created ($COUNT entries)."
    else
        echo "   [!] 'jq' not found. Skipping compile_commands.json generation."
    fi
else
    echo "   [!] No compilation databases found (or ignored)."
fi
rm -f $DB_LIST

# --- PHASE 2: Header Weaving ---
if [ -f "$TARGET_JSON" ]; then
    echo "   [i] Scanning for missing headers..."
    mkdir -p "$VIEW_NAME/_sys/includes"
    
    declare -a WEAVER_CMD
    
    # Priority 1: Local Sibling Script (Best for Dev/Docker Mounts)
    # We prefer this because it allows us to force 'python3' execution
    if [ -f "$SCRIPT_DIR/weave-headers" ]; then
        echo "   [DEBUG] Using local sibling: $SCRIPT_DIR/weave-headers"
        WEAVER_CMD=("python3" "$SCRIPT_DIR/weave-headers")
        
    # Priority 2: System Installed Tool (Best for Production/Nix)
    elif command -v weave-headers &> /dev/null; then
        echo "   [DEBUG] Using system tool: weave-headers"
        WEAVER_CMD=("weave-headers")
    else
        echo "   [!] Warning: weave-headers not found."
        WEAVER_CMD=("false")
    fi

    if [ "${WEAVER_CMD[0]}" != "false" ]; then
        "${WEAVER_CMD[@]}" "$ROOT_DIR" "$VIEW_NAME" "$TARGET_JSON" | while IFS='|' read -r TYPE HEADER_PATH SLUG; do
            if [ "$TYPE" == "INTERNAL" ]; then
                LINK_PATH="$VIEW_NAME/_sys/includes/$SLUG"
                if [ ! -e "$LINK_PATH" ]; then
                    ln -sf "$HEADER_PATH" "$LINK_PATH"
                fi
            elif [ "$TYPE" == "EXTERNAL" ]; then
                echo "      [!] External Include: $HEADER_PATH"
            fi
        done
    fi
fi

echo "_sys/" > "$VIEW_NAME/.aiderignore"
if [ -f .aiderignore ]; then cat .aiderignore >> "$VIEW_NAME/.aiderignore"; fi

if [ -d ".ddd" ]; then
    ln -sf "$ROOT_DIR/.ddd" "$VIEW_NAME/.ddd"
    echo "   [+] Triple-Head Active: Linked .ddd/"
fi

echo "âœ… View Ready: cd $VIEW_NAME"