#!/usr/bin/env bash
set -e

if [ "$#" -lt 2 ]; then
  echo "Usage: weave-view <view-name> <src-dir1> [src-dir2...] [--sys <sdk-dir1>...]"
  exit 1
fi

INPUT_NAME="$1"; shift
if [[ "$INPUT_NAME" == view-* ]]; then VIEW_NAME="$INPUT_NAME"; else VIEW_NAME="view-$INPUT_NAME"; fi

echo "ðŸ§µ Weaving virtual view: $VIEW_NAME"
mkdir -p "$VIEW_NAME/_sys"

JQ_ARGS=""; MODE=0
declare -a SRC_PATHS

# Save PWD to resolve absolute paths correctly
ROOT_DIR="$(pwd)"

for arg in "$@"; do
  if [ "$arg" == "--sys" ]; then MODE=1; continue; fi
  if [[ "$arg" = /* ]]; then ABS="$arg"; else ABS="$ROOT_DIR/$arg"; fi
  
  if [ $MODE -eq 0 ]; then
    REL=$(dirname "$arg"); mkdir -p "$VIEW_NAME/$REL"
    ln -sf "$ABS" "$VIEW_NAME/$arg"
    SRC_PATHS+=("$ABS")
    if [ -z "$JQ_ARGS" ]; then JQ_ARGS=".file | startswith(\"$ABS\")";
    else JQ_ARGS="$JQ_ARGS or (.file | startswith(\"$ABS\"))"; fi
  else
    ln -sf "$ABS" "$VIEW_NAME/_sys/$(basename "$arg")"
  fi
done

echo "   [i] Searching for compilation databases..."
DB_LIST=$(mktemp)
if [ -f "compile_commands.json" ]; then echo "$ROOT_DIR/compile_commands.json" >> $DB_LIST; fi
for path in "${SRC_PATHS[@]}"; do
    find "$path" -maxdepth 3 -name "compile_commands.json" >> $DB_LIST 2>/dev/null || true
done

UNIQUE_DBS=$(cat $DB_LIST | sort | uniq)

if [ ! -z "$UNIQUE_DBS" ] && [ ! -z "$JQ_ARGS" ]; then
    if command -v jq &> /dev/null; then
        # --- PATH FIX: Normalize Host Paths to Container Paths ---
        # 1. Read the raw DB
        RAW_JSON=$(cat $UNIQUE_DBS | jq -s "add")
        
        # 2. Detect Path Mismatch (Heuristic)
        # Grab the first file path from the JSON
        SAMPLE_PATH=$(echo "$RAW_JSON" | jq -r '.[0].file // empty')
        
        if [ ! -z "$SAMPLE_PATH" ] && [[ "$SAMPLE_PATH" != "$ROOT_DIR"* ]]; then
            echo "   [!] Detected Path Mismatch (Host vs Container)"
            echo "       JSON Path: $SAMPLE_PATH"
            echo "       Current Dir: $ROOT_DIR"
            
            # 3. Calculate the Prefix to Strip
            # Assumption: The relative path structure matches.
            # We find where the current directory's name appears in the sample path.
            # E.g. ROOT_DIR=/data, SAMPLE=/Users/bob/repo/src/main.c
            # We want to map /Users/bob/repo -> /data
            
            # Try to guess the host root by stripping the local relative path of the first source arg
            FIRST_SRC="${SRC_PATHS[0]}" 
            # Remove ROOT_DIR from FIRST_SRC to get relative path (e.g., /src/main.c)
            REL_PATH="${FIRST_SRC#$ROOT_DIR}"
            
            # Now remove REL_PATH from the end of SAMPLE_PATH
            HOST_ROOT="${SAMPLE_PATH%$REL_PATH}"
            
            if [ ! -z "$HOST_ROOT" ] && [ "$HOST_ROOT" != "$SAMPLE_PATH" ]; then
                 echo "       Detected Host Root: $HOST_ROOT"
                 echo "       Rewriting to: $ROOT_DIR"
                 RAW_JSON=$(echo "$RAW_JSON" | sed "s|$HOST_ROOT|$ROOT_DIR|g")
            else
                 echo "       [!] Could not auto-detect host root. Compilation DB might be empty."
            fi
        fi

        # 4. Filter
        echo "$RAW_JSON" | jq "[.[] | select($JQ_ARGS)]" > "$VIEW_NAME/compile_commands.json"
        
        COUNT=$(jq length "$VIEW_NAME/compile_commands.json")
        echo "   [âœ“] Master compile_commands.json created ($COUNT entries)."
    else
        echo "   [!] 'jq' not found. Skipping compile_commands.json generation."
    fi
else
    echo "   [!] No compilation databases found (or ignored)."
fi
rm -f $DB_LIST

echo "_sys/" > "$VIEW_NAME/.aiderignore"
if [ -f .aiderignore ]; then cat .aiderignore >> "$VIEW_NAME/.aiderignore"; fi

if [ -d ".ddd" ]; then
    ln -sf "$ROOT_DIR/.ddd" "$VIEW_NAME/.ddd"
    echo "   [+] Triple-Head Active: Linked .ddd/"
fi

echo "âœ… View Ready: cd $VIEW_NAME"